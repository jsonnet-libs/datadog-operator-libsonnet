{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='datadogAgent', url='', help='"DatadogAgent Deployment with the Datadog Operator."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of DatadogAgent', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'datadoghq.com/v2alpha1',
    kind: 'DatadogAgent',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help='"DatadogAgentSpec defines the desired state of DatadogAgent"'),
  spec: {
    '#features':: d.obj(help='"Features running on the Agent and Cluster Agent"'),
    features: {
      '#admissionController':: d.obj(help='"AdmissionController configuration."'),
      admissionController: {
        '#agentSidecarInjection':: d.obj(help='"AgentSidecarInjection contains Agent sidecar injection configurations."'),
        agentSidecarInjection: {
          '#image':: d.obj(help='"Image overrides the default Agent image name and tag for the Agent sidecar."'),
          image: {
            '#pullSecrets':: d.obj(help='"It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod"'),
            pullSecrets: {
              '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
            },
            '#withJmxEnabled':: d.fn(help='"Define whether the Agent image should support JMX. To be used if the Name field does not correspond to a full image string."', args=[d.arg(name='jmxEnabled', type=d.T.boolean)]),
            withJmxEnabled(jmxEnabled): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { image+: { jmxEnabled: jmxEnabled } } } } } },
            '#withName':: d.fn(help='"Define the image to use: Use \\"gcr.io/datadoghq/agent:latest\\" for Datadog Agent 7. Use \\"datadog/dogstatsd:latest\\" for standalone Datadog Agent DogStatsD 7. Use \\"gcr.io/datadoghq/cluster-agent:latest\\" for Datadog Cluster Agent. Use \\"agent\\" with the registry and tag configurations for <registry>/agent:<tag>. Use \\"cluster-agent\\" with the registry and tag configurations for <registry>/cluster-agent:<tag>. If the name is the full image stringâ€”`<name>:<tag>` or `<registry>/<name>:<tag>`, then `tag`, `jmxEnabled`, and `global.registry` values are ignored. Otherwise, image string is created by overriding default settings with supplied `name`, `tag`, and `jmxEnabled` values; image string is created using default registry unless `global.registry` is configured."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { image+: { name: name } } } } } },
            '#withPullPolicy':: d.fn(help='"The Kubernetes pull policy: Use Always, Never, or IfNotPresent."', args=[d.arg(name='pullPolicy', type=d.T.string)]),
            withPullPolicy(pullPolicy): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { image+: { pullPolicy: pullPolicy } } } } } },
            '#withPullSecrets':: d.fn(help='"It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod"', args=[d.arg(name='pullSecrets', type=d.T.array)]),
            withPullSecrets(pullSecrets): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { image+: { pullSecrets: if std.isArray(v=pullSecrets) then pullSecrets else [pullSecrets] } } } } } },
            '#withPullSecretsMixin':: d.fn(help='"It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pullSecrets', type=d.T.array)]),
            withPullSecretsMixin(pullSecrets): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { image+: { pullSecrets+: if std.isArray(v=pullSecrets) then pullSecrets else [pullSecrets] } } } } } },
            '#withTag':: d.fn(help='"Define the image tag to use. To be used if the Name field does not correspond to a full image string."', args=[d.arg(name='tag', type=d.T.string)]),
            withTag(tag): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { image+: { tag: tag } } } } } },
          },
          '#profiles':: d.obj(help='"Profiles define the sidecar configuration override. Only one profile is supported."'),
          profiles: {
            '#env':: d.obj(help='"EnvVars specifies the environment variables for the profile."'),
            env: {
              '#valueFrom':: d.obj(help="\"Source for the environment variable's value. Cannot be used if value is not empty.\""),
              valueFrom: {
                '#configMapKeyRef':: d.obj(help='"Selects a key of a ConfigMap."'),
                configMapKeyRef: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
                  '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
                },
                '#fieldRef':: d.obj(help="\"Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['\u003cKEY\u003e']`, `metadata.annotations['\u003cKEY\u003e']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.\""),
                fieldRef: {
                  '#withApiVersion':: d.fn(help='"Version of the schema the FieldPath is written in terms of, defaults to \\"v1\\"."', args=[d.arg(name='apiVersion', type=d.T.string)]),
                  withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
                  '#withFieldPath':: d.fn(help='"Path of the field to select in the specified API version."', args=[d.arg(name='fieldPath', type=d.T.string)]),
                  withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
                },
                '#resourceFieldRef':: d.obj(help='"Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported."'),
                resourceFieldRef: {
                  '#withContainerName':: d.fn(help='"Container name: required for volumes, optional for env vars"', args=[d.arg(name='containerName', type=d.T.string)]),
                  withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
                  '#withDivisor':: d.fn(help='"Specifies the output format of the exposed resources, defaults to \\"1\\', args=[d.arg(name='divisor', type=d.T.any)]),
                  withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
                  '#withResource':: d.fn(help='"Required: resource to select"', args=[d.arg(name='resource', type=d.T.string)]),
                  withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
                },
                '#secretKeyRef':: d.obj(help="\"Selects a key of a secret in the pod's namespace\""),
                secretKeyRef: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
                  '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
                },
              },
              '#withName':: d.fn(help='"Name of the environment variable. Must be a C_IDENTIFIER."', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='"Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \\"$$(VAR_NAME)\\" will produce the string literal \\"$(VAR_NAME)\\". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \\"\\"."', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#resources':: d.obj(help='"ResourceRequirements specifies the resource requirements for the profile."'),
            resources: {
              '#withLimits':: d.fn(help='"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"', args=[d.arg(name='limits', type=d.T.object)]),
              withLimits(limits): { resources+: { limits: limits } },
              '#withLimitsMixin':: d.fn(help='"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
              withLimitsMixin(limits): { resources+: { limits+: limits } },
              '#withRequests':: d.fn(help='"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"', args=[d.arg(name='requests', type=d.T.object)]),
              withRequests(requests): { resources+: { requests: requests } },
              '#withRequestsMixin':: d.fn(help='"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
              withRequestsMixin(requests): { resources+: { requests+: requests } },
            },
            '#withEnv':: d.fn(help='"EnvVars specifies the environment variables for the profile."', args=[d.arg(name='env', type=d.T.array)]),
            withEnv(env): { env: if std.isArray(v=env) then env else [env] },
            '#withEnvMixin':: d.fn(help='"EnvVars specifies the environment variables for the profile."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
            withEnvMixin(env): { env+: if std.isArray(v=env) then env else [env] },
          },
          '#selectors':: d.obj(help='"Selectors define the pod selector for sidecar injection. Only one rule is supported."'),
          selectors: {
            '#namespaceSelector':: d.obj(help='"NamespaceSelector specifies the label selector for namespaces."'),
            namespaceSelector: {
              '#matchExpressions':: d.obj(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."'),
              matchExpressions: {
                '#withKey':: d.fn(help='"key is the label key that the selector applies to."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help="\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\"", args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { namespaceSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { namespaceSelector+: { matchLabels+: matchLabels } },
            },
            '#objectSelector':: d.obj(help='"ObjectSelector specifies the label selector for objects."'),
            objectSelector: {
              '#matchExpressions':: d.obj(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."'),
              matchExpressions: {
                '#withKey':: d.fn(help='"key is the label key that the selector applies to."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help="\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\"", args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { objectSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { objectSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { objectSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { objectSelector+: { matchLabels+: matchLabels } },
            },
          },
          '#withClusterAgentCommunicationEnabled':: d.fn(help='"ClusterAgentCommunicationEnabled enables communication between Agent sidecars and the Cluster Agent. Default : true"', args=[d.arg(name='clusterAgentCommunicationEnabled', type=d.T.boolean)]),
          withClusterAgentCommunicationEnabled(clusterAgentCommunicationEnabled): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { clusterAgentCommunicationEnabled: clusterAgentCommunicationEnabled } } } } },
          '#withEnabled':: d.fn(help='"Enabled enables Sidecar injections. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { enabled: enabled } } } } },
          '#withProfiles':: d.fn(help='"Profiles define the sidecar configuration override. Only one profile is supported."', args=[d.arg(name='profiles', type=d.T.array)]),
          withProfiles(profiles): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { profiles: if std.isArray(v=profiles) then profiles else [profiles] } } } } },
          '#withProfilesMixin':: d.fn(help='"Profiles define the sidecar configuration override. Only one profile is supported."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='profiles', type=d.T.array)]),
          withProfilesMixin(profiles): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { profiles+: if std.isArray(v=profiles) then profiles else [profiles] } } } } },
          '#withProvider':: d.fn(help='"Provider is used to add infrastructure provider-specific configurations to the Agent sidecar. Currently only \\"fargate\\" is supported. To use the feature in other environments (including local testing) omit the config. See also: https://docs.datadoghq.com/integrations/eks_fargate"', args=[d.arg(name='provider', type=d.T.string)]),
          withProvider(provider): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { provider: provider } } } } },
          '#withRegistry':: d.fn(help='"Registry overrides the default registry for the sidecar Agent."', args=[d.arg(name='registry', type=d.T.string)]),
          withRegistry(registry): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { registry: registry } } } } },
          '#withSelectors':: d.fn(help='"Selectors define the pod selector for sidecar injection. Only one rule is supported."', args=[d.arg(name='selectors', type=d.T.array)]),
          withSelectors(selectors): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { selectors: if std.isArray(v=selectors) then selectors else [selectors] } } } } },
          '#withSelectorsMixin':: d.fn(help='"Selectors define the pod selector for sidecar injection. Only one rule is supported."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='selectors', type=d.T.array)]),
          withSelectorsMixin(selectors): { spec+: { features+: { admissionController+: { agentSidecarInjection+: { selectors+: if std.isArray(v=selectors) then selectors else [selectors] } } } } },
        },
        '#cwsInstrumentation':: d.obj(help='"CWSInstrumentation holds the CWS Instrumentation endpoint configuration"'),
        cwsInstrumentation: {
          '#withEnabled':: d.fn(help='"Enable the CWS Instrumentation admission controller endpoint. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { admissionController+: { cwsInstrumentation+: { enabled: enabled } } } } },
          '#withMode':: d.fn(help='"Mode defines the behavior of the CWS Instrumentation endpoint, and can be either \\"init_container\\" or \\"remote_copy\\". Default: \\"remote_copy\\', args=[d.arg(name='mode', type=d.T.string)]),
          withMode(mode): { spec+: { features+: { admissionController+: { cwsInstrumentation+: { mode: mode } } } } },
        },
        '#withAgentCommunicationMode':: d.fn(help='"AgentCommunicationMode corresponds to the mode used by the Datadog application libraries to communicate with the Agent. It can be \\"hostip\\", \\"service\\", or \\"socket\\"."', args=[d.arg(name='agentCommunicationMode', type=d.T.string)]),
        withAgentCommunicationMode(agentCommunicationMode): { spec+: { features+: { admissionController+: { agentCommunicationMode: agentCommunicationMode } } } },
        '#withEnabled':: d.fn(help='"Enabled enables the Admission Controller. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { admissionController+: { enabled: enabled } } } },
        '#withFailurePolicy':: d.fn(help='"FailurePolicy determines how unrecognized and timeout errors are handled."', args=[d.arg(name='failurePolicy', type=d.T.string)]),
        withFailurePolicy(failurePolicy): { spec+: { features+: { admissionController+: { failurePolicy: failurePolicy } } } },
        '#withMutateUnlabelled':: d.fn(help="\"MutateUnlabelled enables config injection without the need of pod label 'admission.datadoghq.com/enabled=\\\"true\\\"'. Default: false\"", args=[d.arg(name='mutateUnlabelled', type=d.T.boolean)]),
        withMutateUnlabelled(mutateUnlabelled): { spec+: { features+: { admissionController+: { mutateUnlabelled: mutateUnlabelled } } } },
        '#withRegistry':: d.fn(help='"Registry defines an image registry for the admission controller."', args=[d.arg(name='registry', type=d.T.string)]),
        withRegistry(registry): { spec+: { features+: { admissionController+: { registry: registry } } } },
        '#withServiceName':: d.fn(help='"ServiceName corresponds to the webhook service name."', args=[d.arg(name='serviceName', type=d.T.string)]),
        withServiceName(serviceName): { spec+: { features+: { admissionController+: { serviceName: serviceName } } } },
        '#withWebhookName':: d.fn(help='"WebhookName is a custom name for the MutatingWebhookConfiguration. Default: \\"datadog-webhook\\', args=[d.arg(name='webhookName', type=d.T.string)]),
        withWebhookName(webhookName): { spec+: { features+: { admissionController+: { webhookName: webhookName } } } },
      },
      '#apm':: d.obj(help='"APM (Application Performance Monitoring) configuration."'),
      apm: {
        '#hostPortConfig':: d.obj(help='"HostPortConfig contains host port configuration. Enabled Default: false Port Default: 8126"'),
        hostPortConfig: {
          '#withEnabled':: d.fn(help='"Enabled enables host port configuration Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { apm+: { hostPortConfig+: { enabled: enabled } } } } },
          '#withHostPort':: d.fn(help='"Port takes a port number (0 < x < 65536) to expose on the host. (Most containers do not need this.) If HostNetwork is enabled, this value must match the ContainerPort."', args=[d.arg(name='hostPort', type=d.T.integer)]),
          withHostPort(hostPort): { spec+: { features+: { apm+: { hostPortConfig+: { hostPort: hostPort } } } } },
        },
        '#instrumentation':: d.obj(help='"SingleStepInstrumentation allows the agent to inject the Datadog APM libraries into all pods in the cluster. Feature is in beta. See also: https://docs.datadoghq.com/tracing/trace_collection/single-step-apm Enabled Default: false"'),
        instrumentation: {
          '#withDisabledNamespaces':: d.fn(help='"DisabledNamespaces disables injecting the Datadog APM libraries into pods in specific namespaces."', args=[d.arg(name='disabledNamespaces', type=d.T.array)]),
          withDisabledNamespaces(disabledNamespaces): { spec+: { features+: { apm+: { instrumentation+: { disabledNamespaces: if std.isArray(v=disabledNamespaces) then disabledNamespaces else [disabledNamespaces] } } } } },
          '#withDisabledNamespacesMixin':: d.fn(help='"DisabledNamespaces disables injecting the Datadog APM libraries into pods in specific namespaces."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='disabledNamespaces', type=d.T.array)]),
          withDisabledNamespacesMixin(disabledNamespaces): { spec+: { features+: { apm+: { instrumentation+: { disabledNamespaces+: if std.isArray(v=disabledNamespaces) then disabledNamespaces else [disabledNamespaces] } } } } },
          '#withEnabled':: d.fn(help='"Enabled enables injecting the Datadog APM libraries into all pods in the cluster. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { apm+: { instrumentation+: { enabled: enabled } } } } },
          '#withEnabledNamespaces':: d.fn(help='"EnabledNamespaces enables injecting the Datadog APM libraries into pods in specific namespaces."', args=[d.arg(name='enabledNamespaces', type=d.T.array)]),
          withEnabledNamespaces(enabledNamespaces): { spec+: { features+: { apm+: { instrumentation+: { enabledNamespaces: if std.isArray(v=enabledNamespaces) then enabledNamespaces else [enabledNamespaces] } } } } },
          '#withEnabledNamespacesMixin':: d.fn(help='"EnabledNamespaces enables injecting the Datadog APM libraries into pods in specific namespaces."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='enabledNamespaces', type=d.T.array)]),
          withEnabledNamespacesMixin(enabledNamespaces): { spec+: { features+: { apm+: { instrumentation+: { enabledNamespaces+: if std.isArray(v=enabledNamespaces) then enabledNamespaces else [enabledNamespaces] } } } } },
          '#withLibVersions':: d.fn(help='"LibVersions configures injection of specific tracing library versions with Single Step Instrumentation. <Library>: <Version> ex: \\"java\\": \\"v1.18.0\\', args=[d.arg(name='libVersions', type=d.T.object)]),
          withLibVersions(libVersions): { spec+: { features+: { apm+: { instrumentation+: { libVersions: libVersions } } } } },
          '#withLibVersionsMixin':: d.fn(help='"LibVersions configures injection of specific tracing library versions with Single Step Instrumentation. <Library>: <Version> ex: \\"java\\": \\"v1.18.0\\\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='libVersions', type=d.T.object)]),
          withLibVersionsMixin(libVersions): { spec+: { features+: { apm+: { instrumentation+: { libVersions+: libVersions } } } } },
        },
        '#unixDomainSocketConfig':: d.obj(help='"UnixDomainSocketConfig contains socket configuration. See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables Enabled Default: true Path Default: `/var/run/datadog/apm.socket`"'),
        unixDomainSocketConfig: {
          '#withEnabled':: d.fn(help='"Enabled enables Unix Domain Socket. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { apm+: { unixDomainSocketConfig+: { enabled: enabled } } } } },
          '#withPath':: d.fn(help='"Path defines the socket path used when enabled."', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { spec+: { features+: { apm+: { unixDomainSocketConfig+: { path: path } } } } },
        },
        '#withEnabled':: d.fn(help='"Enabled enables Application Performance Monitoring. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { apm+: { enabled: enabled } } } },
      },
      '#asm':: d.obj(help='"ASM (Application Security Management) configuration."'),
      asm: {
        '#iast':: d.obj(help='"IAST configures Interactive Application Security Testing. Enabled Default: false"'),
        iast: {
          '#withEnabled':: d.fn(help='"Enabled enables Interactive Application Security Testing (IAST). Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { asm+: { iast+: { enabled: enabled } } } } },
        },
        '#sca':: d.obj(help='"SCA configures Software Composition Analysis. Enabled Default: false"'),
        sca: {
          '#withEnabled':: d.fn(help='"Enabled enables Software Composition Analysis (SCA). Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { asm+: { sca+: { enabled: enabled } } } } },
        },
        '#threats':: d.obj(help='"Threats configures ASM App & API Protection. Enabled Default: false"'),
        threats: {
          '#withEnabled':: d.fn(help='"Enabled enables ASM App & API Protection. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { asm+: { threats+: { enabled: enabled } } } } },
        },
      },
      '#clusterChecks':: d.obj(help='"ClusterChecks configuration."'),
      clusterChecks: {
        '#withEnabled':: d.fn(help='"Enables Cluster Checks scheduling in the Cluster Agent. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { clusterChecks+: { enabled: enabled } } } },
        '#withUseClusterChecksRunners':: d.fn(help='"Enabled enables Cluster Checks Runners to run all Cluster Checks. Default: false"', args=[d.arg(name='useClusterChecksRunners', type=d.T.boolean)]),
        withUseClusterChecksRunners(useClusterChecksRunners): { spec+: { features+: { clusterChecks+: { useClusterChecksRunners: useClusterChecksRunners } } } },
      },
      '#cspm':: d.obj(help='"CSPM (Cloud Security Posture Management) configuration."'),
      cspm: {
        '#customBenchmarks':: d.obj(help='"CustomBenchmarks contains CSPM benchmarks. The content of the ConfigMap will be merged with the benchmarks bundled with the agent. Any benchmarks with the same name as those existing in the agent will take precedence."'),
        customBenchmarks: {
          '#configMap':: d.obj(help='"ConfigMap references an existing ConfigMap with the configuration file content."'),
          configMap: {
            '#items':: d.obj(help='"Items maps a ConfigMap data `key` to a file `path` mount."'),
            items: {
              '#withKey':: d.fn(help='"key is the key to project."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='"mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set."', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help="\"path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.\"", args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { spec+: { features+: { cspm+: { customBenchmarks+: { configMap+: { items: if std.isArray(v=items) then items else [items] } } } } } },
            '#withItemsMixin':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { spec+: { features+: { cspm+: { customBenchmarks+: { configMap+: { items+: if std.isArray(v=items) then items else [items] } } } } } },
            '#withName':: d.fn(help='"Name is the name of the ConfigMap."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { features+: { cspm+: { customBenchmarks+: { configMap+: { name: name } } } } } },
          },
          '#withConfigData':: d.fn(help='"ConfigData corresponds to the configuration file content."', args=[d.arg(name='configData', type=d.T.string)]),
          withConfigData(configData): { spec+: { features+: { cspm+: { customBenchmarks+: { configData: configData } } } } },
        },
        '#hostBenchmarks':: d.obj(help='"HostBenchmarks contains configuration for host benchmarks."'),
        hostBenchmarks: {
          '#withEnabled':: d.fn(help='"Enabled enables host benchmarks. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { cspm+: { hostBenchmarks+: { enabled: enabled } } } } },
        },
        '#withCheckInterval':: d.fn(help='"CheckInterval defines the check interval."', args=[d.arg(name='checkInterval', type=d.T.string)]),
        withCheckInterval(checkInterval): { spec+: { features+: { cspm+: { checkInterval: checkInterval } } } },
        '#withEnabled':: d.fn(help='"Enabled enables Cloud Security Posture Management. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { cspm+: { enabled: enabled } } } },
      },
      '#cws':: d.obj(help='"CWS (Cloud Workload Security) configuration."'),
      cws: {
        '#customPolicies':: d.obj(help='"CustomPolicies contains security policies. The content of the ConfigMap will be merged with the policies bundled with the agent. Any policies with the same name as those existing in the agent will take precedence."'),
        customPolicies: {
          '#configMap':: d.obj(help='"ConfigMap references an existing ConfigMap with the configuration file content."'),
          configMap: {
            '#items':: d.obj(help='"Items maps a ConfigMap data `key` to a file `path` mount."'),
            items: {
              '#withKey':: d.fn(help='"key is the key to project."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='"mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set."', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help="\"path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.\"", args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { spec+: { features+: { cws+: { customPolicies+: { configMap+: { items: if std.isArray(v=items) then items else [items] } } } } } },
            '#withItemsMixin':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { spec+: { features+: { cws+: { customPolicies+: { configMap+: { items+: if std.isArray(v=items) then items else [items] } } } } } },
            '#withName':: d.fn(help='"Name is the name of the ConfigMap."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { features+: { cws+: { customPolicies+: { configMap+: { name: name } } } } } },
          },
          '#withConfigData':: d.fn(help='"ConfigData corresponds to the configuration file content."', args=[d.arg(name='configData', type=d.T.string)]),
          withConfigData(configData): { spec+: { features+: { cws+: { customPolicies+: { configData: configData } } } } },
        },
        '#network':: d.obj(help=''),
        network: {
          '#withEnabled':: d.fn(help='"Enabled enables Cloud Workload Security Network detections. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { cws+: { network+: { enabled: enabled } } } } },
        },
        '#remoteConfiguration':: d.obj(help=''),
        remoteConfiguration: {
          '#withEnabled':: d.fn(help='"Enabled enables Remote Configuration for Cloud Workload Security. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { cws+: { remoteConfiguration+: { enabled: enabled } } } } },
        },
        '#securityProfiles':: d.obj(help=''),
        securityProfiles: {
          '#withEnabled':: d.fn(help='"Enabled enables Security Profiles collection for Cloud Workload Security. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { cws+: { securityProfiles+: { enabled: enabled } } } } },
        },
        '#withEnabled':: d.fn(help='"Enabled enables Cloud Workload Security. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { cws+: { enabled: enabled } } } },
        '#withSyscallMonitorEnabled':: d.fn(help='"SyscallMonitorEnabled enables Syscall Monitoring (recommended for troubleshooting only). Default: false"', args=[d.arg(name='syscallMonitorEnabled', type=d.T.boolean)]),
        withSyscallMonitorEnabled(syscallMonitorEnabled): { spec+: { features+: { cws+: { syscallMonitorEnabled: syscallMonitorEnabled } } } },
      },
      '#dogstatsd':: d.obj(help='"Dogstatsd configuration."'),
      dogstatsd: {
        '#hostPortConfig':: d.obj(help='"HostPortConfig contains host port configuration. Enabled Default: false Port Default: 8125"'),
        hostPortConfig: {
          '#withEnabled':: d.fn(help='"Enabled enables host port configuration Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { dogstatsd+: { hostPortConfig+: { enabled: enabled } } } } },
          '#withHostPort':: d.fn(help='"Port takes a port number (0 < x < 65536) to expose on the host. (Most containers do not need this.) If HostNetwork is enabled, this value must match the ContainerPort."', args=[d.arg(name='hostPort', type=d.T.integer)]),
          withHostPort(hostPort): { spec+: { features+: { dogstatsd+: { hostPortConfig+: { hostPort: hostPort } } } } },
        },
        '#mapperProfiles':: d.obj(help='"Configure the Dogstasd Mapper Profiles. Can be passed as raw data or via a json encoded string in a config map. See also: https://docs.datadoghq.com/developers/dogstatsd/dogstatsd_mapper/"'),
        mapperProfiles: {
          '#configMap':: d.obj(help='"ConfigMap references an existing ConfigMap with the configuration file content."'),
          configMap: {
            '#items':: d.obj(help='"Items maps a ConfigMap data `key` to a file `path` mount."'),
            items: {
              '#withKey':: d.fn(help='"key is the key to project."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='"mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set."', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help="\"path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.\"", args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { spec+: { features+: { dogstatsd+: { mapperProfiles+: { configMap+: { items: if std.isArray(v=items) then items else [items] } } } } } },
            '#withItemsMixin':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { spec+: { features+: { dogstatsd+: { mapperProfiles+: { configMap+: { items+: if std.isArray(v=items) then items else [items] } } } } } },
            '#withName':: d.fn(help='"Name is the name of the ConfigMap."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { features+: { dogstatsd+: { mapperProfiles+: { configMap+: { name: name } } } } } },
          },
          '#withConfigData':: d.fn(help='"ConfigData corresponds to the configuration file content."', args=[d.arg(name='configData', type=d.T.string)]),
          withConfigData(configData): { spec+: { features+: { dogstatsd+: { mapperProfiles+: { configData: configData } } } } },
        },
        '#unixDomainSocketConfig':: d.obj(help='"UnixDomainSocketConfig contains socket configuration. See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables Enabled Default: true Path Default: `/var/run/datadog/dsd.socket`"'),
        unixDomainSocketConfig: {
          '#withEnabled':: d.fn(help='"Enabled enables Unix Domain Socket. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { dogstatsd+: { unixDomainSocketConfig+: { enabled: enabled } } } } },
          '#withPath':: d.fn(help='"Path defines the socket path used when enabled."', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { spec+: { features+: { dogstatsd+: { unixDomainSocketConfig+: { path: path } } } } },
        },
        '#withOriginDetectionEnabled':: d.fn(help='"OriginDetectionEnabled enables origin detection for container tagging. See also: https://docs.datadoghq.com/developers/dogstatsd/unix_socket/#using-origin-detection-for-container-tagging"', args=[d.arg(name='originDetectionEnabled', type=d.T.boolean)]),
        withOriginDetectionEnabled(originDetectionEnabled): { spec+: { features+: { dogstatsd+: { originDetectionEnabled: originDetectionEnabled } } } },
        '#withTagCardinality':: d.fn(help='"TagCardinality configures tag cardinality for the metrics collected using origin detection (`low`, `orchestrator` or `high`). See also: https://docs.datadoghq.com/getting_started/tagging/assigning_tags/?tab=containerizedenvironments#environment-variables Cardinality default: low"', args=[d.arg(name='tagCardinality', type=d.T.string)]),
        withTagCardinality(tagCardinality): { spec+: { features+: { dogstatsd+: { tagCardinality: tagCardinality } } } },
      },
      '#ebpfCheck':: d.obj(help='"EBPFCheck configuration."'),
      ebpfCheck: {
        '#withEnabled':: d.fn(help='"Enables the eBPF check. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { ebpfCheck+: { enabled: enabled } } } },
      },
      '#eventCollection':: d.obj(help='"EventCollection configuration."'),
      eventCollection: {
        '#withCollectKubernetesEvents':: d.fn(help='"CollectKubernetesEvents enables Kubernetes event collection. Default: true"', args=[d.arg(name='collectKubernetesEvents', type=d.T.boolean)]),
        withCollectKubernetesEvents(collectKubernetesEvents): { spec+: { features+: { eventCollection+: { collectKubernetesEvents: collectKubernetesEvents } } } },
      },
      '#externalMetricsServer':: d.obj(help='"ExternalMetricsServer configuration."'),
      externalMetricsServer: {
        '#endpoint':: d.obj(help='"Override the API endpoint for the External Metrics Server. URL Default: \\"https://app.datadoghq.com\\"."'),
        endpoint: {
          '#credentials':: d.obj(help='"Credentials defines the Datadog credentials used to submit data to/query data from Datadog."'),
          credentials: {
            '#apiSecret':: d.obj(help='"APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over \\"APIKey\\"."'),
            apiSecret: {
              '#withKeyName':: d.fn(help='"KeyName is the key of the secret to use."', args=[d.arg(name='keyName', type=d.T.string)]),
              withKeyName(keyName): { spec+: { features+: { externalMetricsServer+: { endpoint+: { credentials+: { apiSecret+: { keyName: keyName } } } } } } },
              '#withSecretName':: d.fn(help='"SecretName is the name of the secret."', args=[d.arg(name='secretName', type=d.T.string)]),
              withSecretName(secretName): { spec+: { features+: { externalMetricsServer+: { endpoint+: { credentials+: { apiSecret+: { secretName: secretName } } } } } } },
            },
            '#appSecret':: d.obj(help='"AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over \\"AppKey\\"."'),
            appSecret: {
              '#withKeyName':: d.fn(help='"KeyName is the key of the secret to use."', args=[d.arg(name='keyName', type=d.T.string)]),
              withKeyName(keyName): { spec+: { features+: { externalMetricsServer+: { endpoint+: { credentials+: { appSecret+: { keyName: keyName } } } } } } },
              '#withSecretName':: d.fn(help='"SecretName is the name of the secret."', args=[d.arg(name='secretName', type=d.T.string)]),
              withSecretName(secretName): { spec+: { features+: { externalMetricsServer+: { endpoint+: { credentials+: { appSecret+: { secretName: secretName } } } } } } },
            },
            '#withApiKey':: d.fn(help='"APIKey configures your Datadog API key. See also: https://app.datadoghq.com/account/settings#agent/kubernetes"', args=[d.arg(name='apiKey', type=d.T.string)]),
            withApiKey(apiKey): { spec+: { features+: { externalMetricsServer+: { endpoint+: { credentials+: { apiKey: apiKey } } } } } },
            '#withAppKey':: d.fn(help='"AppKey configures your Datadog application key. If you are using features.externalMetricsServer.enabled = true, you must set a Datadog application key for read access to your metrics."', args=[d.arg(name='appKey', type=d.T.string)]),
            withAppKey(appKey): { spec+: { features+: { externalMetricsServer+: { endpoint+: { credentials+: { appKey: appKey } } } } } },
          },
          '#withUrl':: d.fn(help='"URL defines the endpoint URL."', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { spec+: { features+: { externalMetricsServer+: { endpoint+: { url: url } } } } },
        },
        '#withEnabled':: d.fn(help='"Enabled enables the External Metrics Server. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { externalMetricsServer+: { enabled: enabled } } } },
        '#withPort':: d.fn(help='"Port specifies the metricsProvider External Metrics Server service port. Default: 8443"', args=[d.arg(name='port', type=d.T.integer)]),
        withPort(port): { spec+: { features+: { externalMetricsServer+: { port: port } } } },
        '#withRegisterAPIService':: d.fn(help='"RegisterAPIService registers the External Metrics endpoint as an APIService Default: true"', args=[d.arg(name='registerAPIService', type=d.T.boolean)]),
        withRegisterAPIService(registerAPIService): { spec+: { features+: { externalMetricsServer+: { registerAPIService: registerAPIService } } } },
        '#withUseDatadogMetrics':: d.fn(help='"UseDatadogMetrics enables usage of the DatadogMetrics CRD (allowing one to scale on arbitrary Datadog metric queries). Default: true"', args=[d.arg(name='useDatadogMetrics', type=d.T.boolean)]),
        withUseDatadogMetrics(useDatadogMetrics): { spec+: { features+: { externalMetricsServer+: { useDatadogMetrics: useDatadogMetrics } } } },
        '#withWpaController':: d.fn(help='"WPAController enables the informer and controller of the Watermark Pod Autoscaler. NOTE: The Watermark Pod Autoscaler controller needs to be installed. See also: https://github.com/DataDog/watermarkpodautoscaler. Default: false"', args=[d.arg(name='wpaController', type=d.T.boolean)]),
        withWpaController(wpaController): { spec+: { features+: { externalMetricsServer+: { wpaController: wpaController } } } },
      },
      '#helmCheck':: d.obj(help='"HelmCheck configuration."'),
      helmCheck: {
        '#withCollectEvents':: d.fn(help='"CollectEvents set to `true` enables event collection in the Helm check (Requires Agent 7.36.0+ and Cluster Agent 1.20.0+) Default: false"', args=[d.arg(name='collectEvents', type=d.T.boolean)]),
        withCollectEvents(collectEvents): { spec+: { features+: { helmCheck+: { collectEvents: collectEvents } } } },
        '#withEnabled':: d.fn(help='"Enabled enables the Helm check. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { helmCheck+: { enabled: enabled } } } },
        '#withValuesAsTags':: d.fn(help='"ValuesAsTags collects Helm values from a release and uses them as tags (Requires Agent and Cluster Agent 7.40.0+). Default: {}"', args=[d.arg(name='valuesAsTags', type=d.T.object)]),
        withValuesAsTags(valuesAsTags): { spec+: { features+: { helmCheck+: { valuesAsTags: valuesAsTags } } } },
        '#withValuesAsTagsMixin':: d.fn(help='"ValuesAsTags collects Helm values from a release and uses them as tags (Requires Agent and Cluster Agent 7.40.0+). Default: {}"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='valuesAsTags', type=d.T.object)]),
        withValuesAsTagsMixin(valuesAsTags): { spec+: { features+: { helmCheck+: { valuesAsTags+: valuesAsTags } } } },
      },
      '#kubeStateMetricsCore':: d.obj(help='"KubeStateMetricsCore check configuration."'),
      kubeStateMetricsCore: {
        '#conf':: d.obj(help='"Conf overrides the configuration for the default Kubernetes State Metrics Core check. This must point to a ConfigMap containing a valid cluster check configuration."'),
        conf: {
          '#configMap':: d.obj(help='"ConfigMap references an existing ConfigMap with the configuration file content."'),
          configMap: {
            '#items':: d.obj(help='"Items maps a ConfigMap data `key` to a file `path` mount."'),
            items: {
              '#withKey':: d.fn(help='"key is the key to project."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='"mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set."', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help="\"path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.\"", args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { spec+: { features+: { kubeStateMetricsCore+: { conf+: { configMap+: { items: if std.isArray(v=items) then items else [items] } } } } } },
            '#withItemsMixin':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { spec+: { features+: { kubeStateMetricsCore+: { conf+: { configMap+: { items+: if std.isArray(v=items) then items else [items] } } } } } },
            '#withName':: d.fn(help='"Name is the name of the ConfigMap."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { features+: { kubeStateMetricsCore+: { conf+: { configMap+: { name: name } } } } } },
          },
          '#withConfigData':: d.fn(help='"ConfigData corresponds to the configuration file content."', args=[d.arg(name='configData', type=d.T.string)]),
          withConfigData(configData): { spec+: { features+: { kubeStateMetricsCore+: { conf+: { configData: configData } } } } },
        },
        '#withEnabled':: d.fn(help='"Enabled enables Kube State Metrics Core. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { kubeStateMetricsCore+: { enabled: enabled } } } },
      },
      '#liveContainerCollection':: d.obj(help='"LiveContainerCollection configuration."'),
      liveContainerCollection: {
        '#withEnabled':: d.fn(help='"Enables container collection for the Live Container View. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { liveContainerCollection+: { enabled: enabled } } } },
      },
      '#liveProcessCollection':: d.obj(help='"LiveProcessCollection configuration."'),
      liveProcessCollection: {
        '#withEnabled':: d.fn(help='"Enabled enables Process monitoring. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { liveProcessCollection+: { enabled: enabled } } } },
        '#withScrubProcessArguments':: d.fn(help='"ScrubProcessArguments enables scrubbing of sensitive data in process command-lines (passwords, tokens, etc. ). Default: true"', args=[d.arg(name='scrubProcessArguments', type=d.T.boolean)]),
        withScrubProcessArguments(scrubProcessArguments): { spec+: { features+: { liveProcessCollection+: { scrubProcessArguments: scrubProcessArguments } } } },
        '#withStripProcessArguments':: d.fn(help='"StripProcessArguments enables stripping of all process arguments. Default: false"', args=[d.arg(name='stripProcessArguments', type=d.T.boolean)]),
        withStripProcessArguments(stripProcessArguments): { spec+: { features+: { liveProcessCollection+: { stripProcessArguments: stripProcessArguments } } } },
      },
      '#logCollection':: d.obj(help='"LogCollection configuration."'),
      logCollection: {
        '#withContainerCollectAll':: d.fn(help='"ContainerCollectAll enables Log collection from all containers. Default: false"', args=[d.arg(name='containerCollectAll', type=d.T.boolean)]),
        withContainerCollectAll(containerCollectAll): { spec+: { features+: { logCollection+: { containerCollectAll: containerCollectAll } } } },
        '#withContainerCollectUsingFiles':: d.fn(help='"ContainerCollectUsingFiles enables log collection from files in `/var/log/pods instead` of using the container runtime API. Collecting logs from files is usually the most efficient way of collecting logs. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup Default: true"', args=[d.arg(name='containerCollectUsingFiles', type=d.T.boolean)]),
        withContainerCollectUsingFiles(containerCollectUsingFiles): { spec+: { features+: { logCollection+: { containerCollectUsingFiles: containerCollectUsingFiles } } } },
        '#withContainerLogsPath':: d.fn(help='"ContainerLogsPath allows log collection from the container log path. Set to a different path if you are not using the Docker runtime. See also: https://docs.datadoghq.com/agent/kubernetes/daemonset_setup/?tab=k8sfile#create-manifest Default: `/var/lib/docker/containers`"', args=[d.arg(name='containerLogsPath', type=d.T.string)]),
        withContainerLogsPath(containerLogsPath): { spec+: { features+: { logCollection+: { containerLogsPath: containerLogsPath } } } },
        '#withContainerSymlinksPath':: d.fn(help='"ContainerSymlinksPath allows log collection to use symbolic links in this directory to validate container ID -> pod. Default: `/var/log/containers`"', args=[d.arg(name='containerSymlinksPath', type=d.T.string)]),
        withContainerSymlinksPath(containerSymlinksPath): { spec+: { features+: { logCollection+: { containerSymlinksPath: containerSymlinksPath } } } },
        '#withEnabled':: d.fn(help='"Enabled enables Log collection. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { logCollection+: { enabled: enabled } } } },
        '#withOpenFilesLimit':: d.fn(help='"OpenFilesLimit sets the maximum number of log files that the Datadog Agent tails. Increasing this limit can increase resource consumption of the Agent. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup Default: 100"', args=[d.arg(name='openFilesLimit', type=d.T.integer)]),
        withOpenFilesLimit(openFilesLimit): { spec+: { features+: { logCollection+: { openFilesLimit: openFilesLimit } } } },
        '#withPodLogsPath':: d.fn(help='"PodLogsPath allows log collection from a pod log path. Default: `/var/log/pods`"', args=[d.arg(name='podLogsPath', type=d.T.string)]),
        withPodLogsPath(podLogsPath): { spec+: { features+: { logCollection+: { podLogsPath: podLogsPath } } } },
        '#withTempStoragePath':: d.fn(help='"TempStoragePath (always mounted from the host) is used by the Agent to store information about processed log files. If the Agent is restarted, it starts tailing the log files immediately. Default: `/var/lib/datadog-agent/logs`"', args=[d.arg(name='tempStoragePath', type=d.T.string)]),
        withTempStoragePath(tempStoragePath): { spec+: { features+: { logCollection+: { tempStoragePath: tempStoragePath } } } },
      },
      '#npm':: d.obj(help='"NPM (Network Performance Monitoring) configuration."'),
      npm: {
        '#withCollectDNSStats':: d.fn(help='"CollectDNSStats enables DNS stat collection. Default: false"', args=[d.arg(name='collectDNSStats', type=d.T.boolean)]),
        withCollectDNSStats(collectDNSStats): { spec+: { features+: { npm+: { collectDNSStats: collectDNSStats } } } },
        '#withEnableConntrack':: d.fn(help='"EnableConntrack enables the system-probe agent to connect to the netlink/conntrack subsystem to add NAT information to connection data. See also: http://conntrack-tools.netfilter.org/ Default: false"', args=[d.arg(name='enableConntrack', type=d.T.boolean)]),
        withEnableConntrack(enableConntrack): { spec+: { features+: { npm+: { enableConntrack: enableConntrack } } } },
        '#withEnabled':: d.fn(help='"Enabled enables Network Performance Monitoring. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { npm+: { enabled: enabled } } } },
      },
      '#oomKill':: d.obj(help='"OOMKill configuration."'),
      oomKill: {
        '#withEnabled':: d.fn(help='"Enables the OOMKill eBPF-based check. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { oomKill+: { enabled: enabled } } } },
      },
      '#orchestratorExplorer':: d.obj(help='"OrchestratorExplorer check configuration."'),
      orchestratorExplorer: {
        '#conf':: d.obj(help='"Conf overrides the configuration for the default Orchestrator Explorer check. This must point to a ConfigMap containing a valid cluster check configuration."'),
        conf: {
          '#configMap':: d.obj(help='"ConfigMap references an existing ConfigMap with the configuration file content."'),
          configMap: {
            '#items':: d.obj(help='"Items maps a ConfigMap data `key` to a file `path` mount."'),
            items: {
              '#withKey':: d.fn(help='"key is the key to project."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='"mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set."', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help="\"path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.\"", args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { spec+: { features+: { orchestratorExplorer+: { conf+: { configMap+: { items: if std.isArray(v=items) then items else [items] } } } } } },
            '#withItemsMixin':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { spec+: { features+: { orchestratorExplorer+: { conf+: { configMap+: { items+: if std.isArray(v=items) then items else [items] } } } } } },
            '#withName':: d.fn(help='"Name is the name of the ConfigMap."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { features+: { orchestratorExplorer+: { conf+: { configMap+: { name: name } } } } } },
          },
          '#withConfigData':: d.fn(help='"ConfigData corresponds to the configuration file content."', args=[d.arg(name='configData', type=d.T.string)]),
          withConfigData(configData): { spec+: { features+: { orchestratorExplorer+: { conf+: { configData: configData } } } } },
        },
        '#withCustomResources':: d.fn(help='"`CustomResources` defines custom resources for the orchestrator explorer to collect. Each item should follow the convention `group/version/kind`. For example, `datadoghq.com/v1alpha1/datadogmetrics`."', args=[d.arg(name='customResources', type=d.T.array)]),
        withCustomResources(customResources): { spec+: { features+: { orchestratorExplorer+: { customResources: if std.isArray(v=customResources) then customResources else [customResources] } } } },
        '#withCustomResourcesMixin':: d.fn(help='"`CustomResources` defines custom resources for the orchestrator explorer to collect. Each item should follow the convention `group/version/kind`. For example, `datadoghq.com/v1alpha1/datadogmetrics`."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customResources', type=d.T.array)]),
        withCustomResourcesMixin(customResources): { spec+: { features+: { orchestratorExplorer+: { customResources+: if std.isArray(v=customResources) then customResources else [customResources] } } } },
        '#withDdUrl':: d.fn(help='"Override the API endpoint for the Orchestrator Explorer. URL Default: \\"https://orchestrator.datadoghq.com\\"."', args=[d.arg(name='ddUrl', type=d.T.string)]),
        withDdUrl(ddUrl): { spec+: { features+: { orchestratorExplorer+: { ddUrl: ddUrl } } } },
        '#withEnabled':: d.fn(help='"Enabled enables the Orchestrator Explorer. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { orchestratorExplorer+: { enabled: enabled } } } },
        '#withExtraTags':: d.fn(help='"Additional tags to associate with the collected data in the form of `a b c`. This is a Cluster Agent option distinct from DD_TAGS that is used in the Orchestrator Explorer."', args=[d.arg(name='extraTags', type=d.T.array)]),
        withExtraTags(extraTags): { spec+: { features+: { orchestratorExplorer+: { extraTags: if std.isArray(v=extraTags) then extraTags else [extraTags] } } } },
        '#withExtraTagsMixin':: d.fn(help='"Additional tags to associate with the collected data in the form of `a b c`. This is a Cluster Agent option distinct from DD_TAGS that is used in the Orchestrator Explorer."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='extraTags', type=d.T.array)]),
        withExtraTagsMixin(extraTags): { spec+: { features+: { orchestratorExplorer+: { extraTags+: if std.isArray(v=extraTags) then extraTags else [extraTags] } } } },
        '#withScrubContainers':: d.fn(help='"ScrubContainers enables scrubbing of sensitive container data (passwords, tokens, etc. ). Default: true"', args=[d.arg(name='scrubContainers', type=d.T.boolean)]),
        withScrubContainers(scrubContainers): { spec+: { features+: { orchestratorExplorer+: { scrubContainers: scrubContainers } } } },
      },
      '#otlp':: d.obj(help='"OTLP ingest configuration"'),
      otlp: {
        '#receiver':: d.obj(help='"Receiver contains configuration for the OTLP ingest receiver."'),
        receiver: {
          '#protocols':: d.obj(help='"Protocols contains configuration for the OTLP ingest receiver protocols."'),
          protocols: {
            '#grpc':: d.obj(help='"GRPC contains configuration for the OTLP ingest OTLP/gRPC receiver."'),
            grpc: {
              '#withEnabled':: d.fn(help='"Enable the OTLP/gRPC endpoint."', args=[d.arg(name='enabled', type=d.T.boolean)]),
              withEnabled(enabled): { spec+: { features+: { otlp+: { receiver+: { protocols+: { grpc+: { enabled: enabled } } } } } } },
              '#withEndpoint':: d.fn(help="\"Endpoint for OTLP/gRPC. gRPC supports several naming schemes: https://github.com/grpc/grpc/blob/master/doc/naming.md The Datadog Operator supports only 'host:port' (usually `0.0.0.0:port`). Default: `0.0.0.0:4317`.\"", args=[d.arg(name='endpoint', type=d.T.string)]),
              withEndpoint(endpoint): { spec+: { features+: { otlp+: { receiver+: { protocols+: { grpc+: { endpoint: endpoint } } } } } } },
            },
            '#http':: d.obj(help='"HTTP contains configuration for the OTLP ingest OTLP/HTTP receiver."'),
            http: {
              '#withEnabled':: d.fn(help='"Enable the OTLP/HTTP endpoint."', args=[d.arg(name='enabled', type=d.T.boolean)]),
              withEnabled(enabled): { spec+: { features+: { otlp+: { receiver+: { protocols+: { http+: { enabled: enabled } } } } } } },
              '#withEndpoint':: d.fn(help="\"Endpoint for OTLP/HTTP. Default: '0.0.0.0:4318'.\"", args=[d.arg(name='endpoint', type=d.T.string)]),
              withEndpoint(endpoint): { spec+: { features+: { otlp+: { receiver+: { protocols+: { http+: { endpoint: endpoint } } } } } } },
            },
          },
        },
      },
      '#processDiscovery':: d.obj(help='"ProcessDiscovery configuration."'),
      processDiscovery: {
        '#withEnabled':: d.fn(help='"Enabled enables the Process Discovery check in the Agent. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { processDiscovery+: { enabled: enabled } } } },
      },
      '#prometheusScrape':: d.obj(help='"PrometheusScrape configuration."'),
      prometheusScrape: {
        '#withAdditionalConfigs':: d.fn(help='"AdditionalConfigs allows adding advanced Prometheus check configurations with custom discovery rules."', args=[d.arg(name='additionalConfigs', type=d.T.string)]),
        withAdditionalConfigs(additionalConfigs): { spec+: { features+: { prometheusScrape+: { additionalConfigs: additionalConfigs } } } },
        '#withEnableServiceEndpoints':: d.fn(help='"EnableServiceEndpoints enables generating dedicated checks for service endpoints. Default: false"', args=[d.arg(name='enableServiceEndpoints', type=d.T.boolean)]),
        withEnableServiceEndpoints(enableServiceEndpoints): { spec+: { features+: { prometheusScrape+: { enableServiceEndpoints: enableServiceEndpoints } } } },
        '#withEnabled':: d.fn(help='"Enable autodiscovery of pods and services exposing Prometheus metrics. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { prometheusScrape+: { enabled: enabled } } } },
        '#withVersion':: d.fn(help='"Version specifies the version of the OpenMetrics check. Default: 2"', args=[d.arg(name='version', type=d.T.integer)]),
        withVersion(version): { spec+: { features+: { prometheusScrape+: { version: version } } } },
      },
      '#remoteConfiguration':: d.obj(help='"Remote Configuration configuration."'),
      remoteConfiguration: {
        '#withEnabled':: d.fn(help='"Enable this option to activate Remote Configuration. Default: true"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { remoteConfiguration+: { enabled: enabled } } } },
      },
      '#sbom':: d.obj(help='"SBOM collection configuration."'),
      sbom: {
        '#containerImage':: d.obj(help='"SBOMTypeConfig contains configuration for a SBOM collection type."'),
        containerImage: {
          '#withAnalyzers':: d.fn(help='"Analyzers to use for SBOM collection."', args=[d.arg(name='analyzers', type=d.T.array)]),
          withAnalyzers(analyzers): { spec+: { features+: { sbom+: { containerImage+: { analyzers: if std.isArray(v=analyzers) then analyzers else [analyzers] } } } } },
          '#withAnalyzersMixin':: d.fn(help='"Analyzers to use for SBOM collection."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='analyzers', type=d.T.array)]),
          withAnalyzersMixin(analyzers): { spec+: { features+: { sbom+: { containerImage+: { analyzers+: if std.isArray(v=analyzers) then analyzers else [analyzers] } } } } },
          '#withEnabled':: d.fn(help='"Enable this option to activate SBOM collection. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { sbom+: { containerImage+: { enabled: enabled } } } } },
        },
        '#host':: d.obj(help='"SBOMTypeConfig contains configuration for a SBOM collection type."'),
        host: {
          '#withAnalyzers':: d.fn(help='"Analyzers to use for SBOM collection."', args=[d.arg(name='analyzers', type=d.T.array)]),
          withAnalyzers(analyzers): { spec+: { features+: { sbom+: { host+: { analyzers: if std.isArray(v=analyzers) then analyzers else [analyzers] } } } } },
          '#withAnalyzersMixin':: d.fn(help='"Analyzers to use for SBOM collection."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='analyzers', type=d.T.array)]),
          withAnalyzersMixin(analyzers): { spec+: { features+: { sbom+: { host+: { analyzers+: if std.isArray(v=analyzers) then analyzers else [analyzers] } } } } },
          '#withEnabled':: d.fn(help='"Enable this option to activate SBOM collection. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { spec+: { features+: { sbom+: { host+: { enabled: enabled } } } } },
        },
        '#withEnabled':: d.fn(help='"Enable this option to activate SBOM collection. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { sbom+: { enabled: enabled } } } },
      },
      '#tcpQueueLength':: d.obj(help='"TCPQueueLength configuration."'),
      tcpQueueLength: {
        '#withEnabled':: d.fn(help='"Enables the TCP queue length eBPF-based check. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { tcpQueueLength+: { enabled: enabled } } } },
      },
      '#usm':: d.obj(help='"USM (Universal Service Monitoring) configuration."'),
      usm: {
        '#withEnabled':: d.fn(help='"Enabled enables Universal Service Monitoring. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { features+: { usm+: { enabled: enabled } } } },
      },
    },
    '#global':: d.obj(help='"Global settings to configure the agents"'),
    global: {
      '#clusterAgentTokenSecret':: d.obj(help='"ClusterAgentTokenSecret is the secret containing the Cluster Agent token."'),
      clusterAgentTokenSecret: {
        '#withKeyName':: d.fn(help='"KeyName is the key of the secret to use."', args=[d.arg(name='keyName', type=d.T.string)]),
        withKeyName(keyName): { spec+: { global+: { clusterAgentTokenSecret+: { keyName: keyName } } } },
        '#withSecretName':: d.fn(help='"SecretName is the name of the secret."', args=[d.arg(name='secretName', type=d.T.string)]),
        withSecretName(secretName): { spec+: { global+: { clusterAgentTokenSecret+: { secretName: secretName } } } },
      },
      '#credentials':: d.obj(help='"Credentials defines the Datadog credentials used to submit data to/query data from Datadog."'),
      credentials: {
        '#apiSecret':: d.obj(help='"APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over \\"APIKey\\"."'),
        apiSecret: {
          '#withKeyName':: d.fn(help='"KeyName is the key of the secret to use."', args=[d.arg(name='keyName', type=d.T.string)]),
          withKeyName(keyName): { spec+: { global+: { credentials+: { apiSecret+: { keyName: keyName } } } } },
          '#withSecretName':: d.fn(help='"SecretName is the name of the secret."', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { spec+: { global+: { credentials+: { apiSecret+: { secretName: secretName } } } } },
        },
        '#appSecret':: d.obj(help='"AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over \\"AppKey\\"."'),
        appSecret: {
          '#withKeyName':: d.fn(help='"KeyName is the key of the secret to use."', args=[d.arg(name='keyName', type=d.T.string)]),
          withKeyName(keyName): { spec+: { global+: { credentials+: { appSecret+: { keyName: keyName } } } } },
          '#withSecretName':: d.fn(help='"SecretName is the name of the secret."', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { spec+: { global+: { credentials+: { appSecret+: { secretName: secretName } } } } },
        },
        '#withApiKey':: d.fn(help='"APIKey configures your Datadog API key. See also: https://app.datadoghq.com/account/settings#agent/kubernetes"', args=[d.arg(name='apiKey', type=d.T.string)]),
        withApiKey(apiKey): { spec+: { global+: { credentials+: { apiKey: apiKey } } } },
        '#withAppKey':: d.fn(help='"AppKey configures your Datadog application key. If you are using features.externalMetricsServer.enabled = true, you must set a Datadog application key for read access to your metrics."', args=[d.arg(name='appKey', type=d.T.string)]),
        withAppKey(appKey): { spec+: { global+: { credentials+: { appKey: appKey } } } },
      },
      '#endpoint':: d.obj(help='"Endpoint is the Datadog intake URL the Agent data are sent to. Only set this option if you need the Agent to send data to a custom URL. Overrides the site setting defined in `Site`."'),
      endpoint: {
        '#credentials':: d.obj(help='"Credentials defines the Datadog credentials used to submit data to/query data from Datadog."'),
        credentials: {
          '#apiSecret':: d.obj(help='"APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over \\"APIKey\\"."'),
          apiSecret: {
            '#withKeyName':: d.fn(help='"KeyName is the key of the secret to use."', args=[d.arg(name='keyName', type=d.T.string)]),
            withKeyName(keyName): { spec+: { global+: { endpoint+: { credentials+: { apiSecret+: { keyName: keyName } } } } } },
            '#withSecretName':: d.fn(help='"SecretName is the name of the secret."', args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { spec+: { global+: { endpoint+: { credentials+: { apiSecret+: { secretName: secretName } } } } } },
          },
          '#appSecret':: d.obj(help='"AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over \\"AppKey\\"."'),
          appSecret: {
            '#withKeyName':: d.fn(help='"KeyName is the key of the secret to use."', args=[d.arg(name='keyName', type=d.T.string)]),
            withKeyName(keyName): { spec+: { global+: { endpoint+: { credentials+: { appSecret+: { keyName: keyName } } } } } },
            '#withSecretName':: d.fn(help='"SecretName is the name of the secret."', args=[d.arg(name='secretName', type=d.T.string)]),
            withSecretName(secretName): { spec+: { global+: { endpoint+: { credentials+: { appSecret+: { secretName: secretName } } } } } },
          },
          '#withApiKey':: d.fn(help='"APIKey configures your Datadog API key. See also: https://app.datadoghq.com/account/settings#agent/kubernetes"', args=[d.arg(name='apiKey', type=d.T.string)]),
          withApiKey(apiKey): { spec+: { global+: { endpoint+: { credentials+: { apiKey: apiKey } } } } },
          '#withAppKey':: d.fn(help='"AppKey configures your Datadog application key. If you are using features.externalMetricsServer.enabled = true, you must set a Datadog application key for read access to your metrics."', args=[d.arg(name='appKey', type=d.T.string)]),
          withAppKey(appKey): { spec+: { global+: { endpoint+: { credentials+: { appKey: appKey } } } } },
        },
        '#withUrl':: d.fn(help='"URL defines the endpoint URL."', args=[d.arg(name='url', type=d.T.string)]),
        withUrl(url): { spec+: { global+: { endpoint+: { url: url } } } },
      },
      '#fips':: d.obj(help='"FIPS contains configuration used to customize the FIPS proxy sidecar."'),
      fips: {
        '#customFIPSConfig':: d.obj(help='"CustomFIPSConfig configures a custom configMap to provide the FIPS configuration. Specify custom contents for the FIPS proxy sidecar container config (/etc/datadog-fips-proxy/datadog-fips-proxy.cfg). If empty, the default FIPS proxy sidecar container config is used."'),
        customFIPSConfig: {
          '#configMap':: d.obj(help='"ConfigMap references an existing ConfigMap with the configuration file content."'),
          configMap: {
            '#items':: d.obj(help='"Items maps a ConfigMap data `key` to a file `path` mount."'),
            items: {
              '#withKey':: d.fn(help='"key is the key to project."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='"mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set."', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help="\"path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.\"", args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { spec+: { global+: { fips+: { customFIPSConfig+: { configMap+: { items: if std.isArray(v=items) then items else [items] } } } } } },
            '#withItemsMixin':: d.fn(help='"Items maps a ConfigMap data `key` to a file `path` mount."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { spec+: { global+: { fips+: { customFIPSConfig+: { configMap+: { items+: if std.isArray(v=items) then items else [items] } } } } } },
            '#withName':: d.fn(help='"Name is the name of the ConfigMap."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { global+: { fips+: { customFIPSConfig+: { configMap+: { name: name } } } } } },
          },
          '#withConfigData':: d.fn(help='"ConfigData corresponds to the configuration file content."', args=[d.arg(name='configData', type=d.T.string)]),
          withConfigData(configData): { spec+: { global+: { fips+: { customFIPSConfig+: { configData: configData } } } } },
        },
        '#image':: d.obj(help='"The container image of the FIPS sidecar."'),
        image: {
          '#pullSecrets':: d.obj(help='"It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod"'),
          pullSecrets: {
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
          },
          '#withJmxEnabled':: d.fn(help='"Define whether the Agent image should support JMX. To be used if the Name field does not correspond to a full image string."', args=[d.arg(name='jmxEnabled', type=d.T.boolean)]),
          withJmxEnabled(jmxEnabled): { spec+: { global+: { fips+: { image+: { jmxEnabled: jmxEnabled } } } } },
          '#withName':: d.fn(help='"Define the image to use: Use \\"gcr.io/datadoghq/agent:latest\\" for Datadog Agent 7. Use \\"datadog/dogstatsd:latest\\" for standalone Datadog Agent DogStatsD 7. Use \\"gcr.io/datadoghq/cluster-agent:latest\\" for Datadog Cluster Agent. Use \\"agent\\" with the registry and tag configurations for <registry>/agent:<tag>. Use \\"cluster-agent\\" with the registry and tag configurations for <registry>/cluster-agent:<tag>. If the name is the full image stringâ€”`<name>:<tag>` or `<registry>/<name>:<tag>`, then `tag`, `jmxEnabled`, and `global.registry` values are ignored. Otherwise, image string is created by overriding default settings with supplied `name`, `tag`, and `jmxEnabled` values; image string is created using default registry unless `global.registry` is configured."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { spec+: { global+: { fips+: { image+: { name: name } } } } },
          '#withPullPolicy':: d.fn(help='"The Kubernetes pull policy: Use Always, Never, or IfNotPresent."', args=[d.arg(name='pullPolicy', type=d.T.string)]),
          withPullPolicy(pullPolicy): { spec+: { global+: { fips+: { image+: { pullPolicy: pullPolicy } } } } },
          '#withPullSecrets':: d.fn(help='"It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod"', args=[d.arg(name='pullSecrets', type=d.T.array)]),
          withPullSecrets(pullSecrets): { spec+: { global+: { fips+: { image+: { pullSecrets: if std.isArray(v=pullSecrets) then pullSecrets else [pullSecrets] } } } } },
          '#withPullSecretsMixin':: d.fn(help='"It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pullSecrets', type=d.T.array)]),
          withPullSecretsMixin(pullSecrets): { spec+: { global+: { fips+: { image+: { pullSecrets+: if std.isArray(v=pullSecrets) then pullSecrets else [pullSecrets] } } } } },
          '#withTag':: d.fn(help='"Define the image tag to use. To be used if the Name field does not correspond to a full image string."', args=[d.arg(name='tag', type=d.T.string)]),
          withTag(tag): { spec+: { global+: { fips+: { image+: { tag: tag } } } } },
        },
        '#resources':: d.obj(help='"Resources is the requests and limits for the FIPS sidecar container."'),
        resources: {
          '#withLimits':: d.fn(help='"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { spec+: { global+: { fips+: { resources+: { limits: limits } } } } },
          '#withLimitsMixin':: d.fn(help='"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { spec+: { global+: { fips+: { resources+: { limits+: limits } } } } },
          '#withRequests':: d.fn(help='"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { spec+: { global+: { fips+: { resources+: { requests: requests } } } } },
          '#withRequestsMixin':: d.fn(help='"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { spec+: { global+: { fips+: { resources+: { requests+: requests } } } } },
        },
        '#withEnabled':: d.fn(help='"Enable FIPS sidecar."', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { global+: { fips+: { enabled: enabled } } } },
        '#withLocalAddress':: d.fn(help='"Set the local IP address. Default: `127.0.0.1`"', args=[d.arg(name='localAddress', type=d.T.string)]),
        withLocalAddress(localAddress): { spec+: { global+: { fips+: { localAddress: localAddress } } } },
        '#withPort':: d.fn(help='"Port specifies which port is used by the containers to communicate to the FIPS sidecar. Default: 9803"', args=[d.arg(name='port', type=d.T.integer)]),
        withPort(port): { spec+: { global+: { fips+: { port: port } } } },
        '#withPortRange':: d.fn(help='"PortRange specifies the number of ports used. Default: 15"', args=[d.arg(name='portRange', type=d.T.integer)]),
        withPortRange(portRange): { spec+: { global+: { fips+: { portRange: portRange } } } },
        '#withUseHTTPS':: d.fn(help='"UseHTTPS enables HTTPS. Default: false"', args=[d.arg(name='useHTTPS', type=d.T.boolean)]),
        withUseHTTPS(useHTTPS): { spec+: { global+: { fips+: { useHTTPS: useHTTPS } } } },
      },
      '#kubelet':: d.obj(help='"Kubelet contains the kubelet configuration parameters."'),
      kubelet: {
        '#host':: d.obj(help='"Host overrides the host used to contact kubelet API (default to status.hostIP)."'),
        host: {
          '#configMapKeyRef':: d.obj(help='"Selects a key of a ConfigMap."'),
          configMapKeyRef: {
            '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { spec+: { global+: { kubelet+: { host+: { configMapKeyRef+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { global+: { kubelet+: { host+: { configMapKeyRef+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { spec+: { global+: { kubelet+: { host+: { configMapKeyRef+: { optional: optional } } } } } },
          },
          '#fieldRef':: d.obj(help="\"Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['\u003cKEY\u003e']`, `metadata.annotations['\u003cKEY\u003e']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.\""),
          fieldRef: {
            '#withApiVersion':: d.fn(help='"Version of the schema the FieldPath is written in terms of, defaults to \\"v1\\"."', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { spec+: { global+: { kubelet+: { host+: { fieldRef+: { apiVersion: apiVersion } } } } } },
            '#withFieldPath':: d.fn(help='"Path of the field to select in the specified API version."', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { spec+: { global+: { kubelet+: { host+: { fieldRef+: { fieldPath: fieldPath } } } } } },
          },
          '#resourceFieldRef':: d.obj(help='"Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported."'),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='"Container name: required for volumes, optional for env vars"', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { spec+: { global+: { kubelet+: { host+: { resourceFieldRef+: { containerName: containerName } } } } } },
            '#withDivisor':: d.fn(help='"Specifies the output format of the exposed resources, defaults to \\"1\\', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { spec+: { global+: { kubelet+: { host+: { resourceFieldRef+: { divisor: divisor } } } } } },
            '#withResource':: d.fn(help='"Required: resource to select"', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { spec+: { global+: { kubelet+: { host+: { resourceFieldRef+: { resource: resource } } } } } },
          },
          '#secretKeyRef':: d.obj(help="\"Selects a key of a secret in the pod's namespace\""),
          secretKeyRef: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { spec+: { global+: { kubelet+: { host+: { secretKeyRef+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { global+: { kubelet+: { host+: { secretKeyRef+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { spec+: { global+: { kubelet+: { host+: { secretKeyRef+: { optional: optional } } } } } },
          },
        },
        '#withAgentCAPath':: d.fn(help="\"AgentCAPath is the container path where the kubelet CA certificate is stored. Default: '/var/run/host-kubelet-ca.crt' if hostCAPath is set, else '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'\"", args=[d.arg(name='agentCAPath', type=d.T.string)]),
        withAgentCAPath(agentCAPath): { spec+: { global+: { kubelet+: { agentCAPath: agentCAPath } } } },
        '#withHostCAPath':: d.fn(help='"HostCAPath is the host path where the kubelet CA certificate is stored."', args=[d.arg(name='hostCAPath', type=d.T.string)]),
        withHostCAPath(hostCAPath): { spec+: { global+: { kubelet+: { hostCAPath: hostCAPath } } } },
        '#withTlsVerify':: d.fn(help='"TLSVerify toggles kubelet TLS verification. Default: true"', args=[d.arg(name='tlsVerify', type=d.T.boolean)]),
        withTlsVerify(tlsVerify): { spec+: { global+: { kubelet+: { tlsVerify: tlsVerify } } } },
      },
      '#localService':: d.obj(help='"LocalService contains configuration to customize the internal traffic policy service."'),
      localService: {
        '#withForceEnableLocalService':: d.fn(help='"ForceEnableLocalService forces the creation of the internal traffic policy service to target the agent running on the local node. This parameter only applies to Kubernetes 1.21, where the feature is in alpha and is disabled by default. (On Kubernetes 1.22+, the feature entered beta and the internal traffic service is created by default, so this parameter is ignored.) Default: false"', args=[d.arg(name='forceEnableLocalService', type=d.T.boolean)]),
        withForceEnableLocalService(forceEnableLocalService): { spec+: { global+: { localService+: { forceEnableLocalService: forceEnableLocalService } } } },
        '#withNameOverride':: d.fn(help='"NameOverride defines the name of the internal traffic service to target the agent running on the local node."', args=[d.arg(name='nameOverride', type=d.T.string)]),
        withNameOverride(nameOverride): { spec+: { global+: { localService+: { nameOverride: nameOverride } } } },
      },
      '#networkPolicy':: d.obj(help='"NetworkPolicy contains the network configuration."'),
      networkPolicy: {
        '#dnsSelectorEndpoints':: d.obj(help='"DNSSelectorEndpoints defines the cilium selector of the DNS\\u202fserver entity."'),
        dnsSelectorEndpoints: {
          '#matchExpressions':: d.obj(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."'),
          matchExpressions: {
            '#withKey':: d.fn(help='"key is the label key that the selector applies to."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withOperator':: d.fn(help="\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\"", args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { operator: operator },
            '#withValues':: d.fn(help='"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."', args=[d.arg(name='values', type=d.T.array)]),
            withValues(values): { values: if std.isArray(v=values) then values else [values] },
            '#withValuesMixin':: d.fn(help='"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
            withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
          },
          '#withMatchExpressions':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."', args=[d.arg(name='matchExpressions', type=d.T.array)]),
          withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
          '#withMatchExpressionsMixin':: d.fn(help='"matchExpressions is a list of label selector requirements. The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
          withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
          '#withMatchLabels':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { matchLabels: matchLabels },
          '#withMatchLabelsMixin':: d.fn(help='"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { matchLabels+: matchLabels },
        },
        '#withCreate':: d.fn(help='"Create defines whether to create a NetworkPolicy for the current deployment."', args=[d.arg(name='create', type=d.T.boolean)]),
        withCreate(create): { spec+: { global+: { networkPolicy+: { create: create } } } },
        '#withDnsSelectorEndpoints':: d.fn(help='"DNSSelectorEndpoints defines the cilium selector of the DNS\\u202fserver entity."', args=[d.arg(name='dnsSelectorEndpoints', type=d.T.array)]),
        withDnsSelectorEndpoints(dnsSelectorEndpoints): { spec+: { global+: { networkPolicy+: { dnsSelectorEndpoints: if std.isArray(v=dnsSelectorEndpoints) then dnsSelectorEndpoints else [dnsSelectorEndpoints] } } } },
        '#withDnsSelectorEndpointsMixin':: d.fn(help='"DNSSelectorEndpoints defines the cilium selector of the DNS\\u202fserver entity."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dnsSelectorEndpoints', type=d.T.array)]),
        withDnsSelectorEndpointsMixin(dnsSelectorEndpoints): { spec+: { global+: { networkPolicy+: { dnsSelectorEndpoints+: if std.isArray(v=dnsSelectorEndpoints) then dnsSelectorEndpoints else [dnsSelectorEndpoints] } } } },
        '#withFlavor':: d.fn(help='"Flavor defines Which network policy to use."', args=[d.arg(name='flavor', type=d.T.string)]),
        withFlavor(flavor): { spec+: { global+: { networkPolicy+: { flavor: flavor } } } },
      },
      '#originDetectionUnified':: d.obj(help='"OriginDetectionUnified defines the origin detection unified mechanism behavior."'),
      originDetectionUnified: {
        '#withEnabled':: d.fn(help='"Enabled enables unified mechanism for origin detection. Default: false"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { spec+: { global+: { originDetectionUnified+: { enabled: enabled } } } },
      },
      '#withClusterAgentToken':: d.fn(help='"ClusterAgentToken is the token for communication between the NodeAgent and ClusterAgent."', args=[d.arg(name='clusterAgentToken', type=d.T.string)]),
      withClusterAgentToken(clusterAgentToken): { spec+: { global+: { clusterAgentToken: clusterAgentToken } } },
      '#withClusterName':: d.fn(help='"ClusterName sets a unique cluster name for the deployment to easily scope monitoring data in the Datadog app."', args=[d.arg(name='clusterName', type=d.T.string)]),
      withClusterName(clusterName): { spec+: { global+: { clusterName: clusterName } } },
      '#withContainerStrategy':: d.fn(help="\"ContainerStrategy determines whether agents run in a single or multiple containers. Default: 'optimized'\"", args=[d.arg(name='containerStrategy', type=d.T.string)]),
      withContainerStrategy(containerStrategy): { spec+: { global+: { containerStrategy: containerStrategy } } },
      '#withCriSocketPath':: d.fn(help='"Path to the container runtime socket (if different from Docker)."', args=[d.arg(name='criSocketPath', type=d.T.string)]),
      withCriSocketPath(criSocketPath): { spec+: { global+: { criSocketPath: criSocketPath } } },
      '#withDisableNonResourceRules':: d.fn(help="\"Set DisableNonResourceRules to exclude NonResourceURLs from default ClusterRoles. Required 'true' for Google Cloud Marketplace.\"", args=[d.arg(name='disableNonResourceRules', type=d.T.boolean)]),
      withDisableNonResourceRules(disableNonResourceRules): { spec+: { global+: { disableNonResourceRules: disableNonResourceRules } } },
      '#withDockerSocketPath':: d.fn(help='"Path to the docker runtime socket."', args=[d.arg(name='dockerSocketPath', type=d.T.string)]),
      withDockerSocketPath(dockerSocketPath): { spec+: { global+: { dockerSocketPath: dockerSocketPath } } },
      '#withLogLevel':: d.fn(help="\"LogLevel sets logging verbosity. This can be overridden by container. Valid log levels are: trace, debug, info, warn, error, critical, and off. Default: 'info'\"", args=[d.arg(name='logLevel', type=d.T.string)]),
      withLogLevel(logLevel): { spec+: { global+: { logLevel: logLevel } } },
      '#withNamespaceLabelsAsTags':: d.fn(help='"Provide a mapping of Kubernetes Namespace Labels to Datadog Tags. <KUBERNETES_NAMESPACE_LABEL>: <DATADOG_TAG_KEY>"', args=[d.arg(name='namespaceLabelsAsTags', type=d.T.object)]),
      withNamespaceLabelsAsTags(namespaceLabelsAsTags): { spec+: { global+: { namespaceLabelsAsTags: namespaceLabelsAsTags } } },
      '#withNamespaceLabelsAsTagsMixin':: d.fn(help='"Provide a mapping of Kubernetes Namespace Labels to Datadog Tags. <KUBERNETES_NAMESPACE_LABEL>: <DATADOG_TAG_KEY>"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaceLabelsAsTags', type=d.T.object)]),
      withNamespaceLabelsAsTagsMixin(namespaceLabelsAsTags): { spec+: { global+: { namespaceLabelsAsTags+: namespaceLabelsAsTags } } },
      '#withNodeLabelsAsTags':: d.fn(help='"Provide a mapping of Kubernetes Node Labels to Datadog Tags. <KUBERNETES_NODE_LABEL>: <DATADOG_TAG_KEY>"', args=[d.arg(name='nodeLabelsAsTags', type=d.T.object)]),
      withNodeLabelsAsTags(nodeLabelsAsTags): { spec+: { global+: { nodeLabelsAsTags: nodeLabelsAsTags } } },
      '#withNodeLabelsAsTagsMixin':: d.fn(help='"Provide a mapping of Kubernetes Node Labels to Datadog Tags. <KUBERNETES_NODE_LABEL>: <DATADOG_TAG_KEY>"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeLabelsAsTags', type=d.T.object)]),
      withNodeLabelsAsTagsMixin(nodeLabelsAsTags): { spec+: { global+: { nodeLabelsAsTags+: nodeLabelsAsTags } } },
      '#withPodAnnotationsAsTags':: d.fn(help='"Provide a mapping of Kubernetes Annotations to Datadog Tags. <KUBERNETES_ANNOTATIONS>: <DATADOG_TAG_KEY>"', args=[d.arg(name='podAnnotationsAsTags', type=d.T.object)]),
      withPodAnnotationsAsTags(podAnnotationsAsTags): { spec+: { global+: { podAnnotationsAsTags: podAnnotationsAsTags } } },
      '#withPodAnnotationsAsTagsMixin':: d.fn(help='"Provide a mapping of Kubernetes Annotations to Datadog Tags. <KUBERNETES_ANNOTATIONS>: <DATADOG_TAG_KEY>"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='podAnnotationsAsTags', type=d.T.object)]),
      withPodAnnotationsAsTagsMixin(podAnnotationsAsTags): { spec+: { global+: { podAnnotationsAsTags+: podAnnotationsAsTags } } },
      '#withPodLabelsAsTags':: d.fn(help='"Provide a mapping of Kubernetes Labels to Datadog Tags. <KUBERNETES_LABEL>: <DATADOG_TAG_KEY>"', args=[d.arg(name='podLabelsAsTags', type=d.T.object)]),
      withPodLabelsAsTags(podLabelsAsTags): { spec+: { global+: { podLabelsAsTags: podLabelsAsTags } } },
      '#withPodLabelsAsTagsMixin':: d.fn(help='"Provide a mapping of Kubernetes Labels to Datadog Tags. <KUBERNETES_LABEL>: <DATADOG_TAG_KEY>"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='podLabelsAsTags', type=d.T.object)]),
      withPodLabelsAsTagsMixin(podLabelsAsTags): { spec+: { global+: { podLabelsAsTags+: podLabelsAsTags } } },
      '#withRegistry':: d.fn(help="\"Registry is the image registry to use for all Agent images. Use 'public.ecr.aws/datadog' for AWS ECR. Use 'docker.io/datadog' for DockerHub. Default: 'gcr.io/datadoghq'\"", args=[d.arg(name='registry', type=d.T.string)]),
      withRegistry(registry): { spec+: { global+: { registry: registry } } },
      '#withSite':: d.fn(help="\"Site is the Datadog intake site Agent data are sent to. Set to 'datadoghq.com' to send data to the US1 site (default). Set to 'datadoghq.eu' to send data to the EU site. Set to 'us3.datadoghq.com' to send data to the US3 site. Set to 'us5.datadoghq.com' to send data to the US5 site. Set to 'ddog-gov.com' to send data to the US1-FED site. Set to 'ap1.datadoghq.com' to send data to the AP1 site. Default: 'datadoghq.com'\"", args=[d.arg(name='site', type=d.T.string)]),
      withSite(site): { spec+: { global+: { site: site } } },
      '#withTags':: d.fn(help='"Tags contains a list of tags to attach to every metric, event and service check collected. Learn more about tagging: https://docs.datadoghq.com/tagging/"', args=[d.arg(name='tags', type=d.T.array)]),
      withTags(tags): { spec+: { global+: { tags: if std.isArray(v=tags) then tags else [tags] } } },
      '#withTagsMixin':: d.fn(help='"Tags contains a list of tags to attach to every metric, event and service check collected. Learn more about tagging: https://docs.datadoghq.com/tagging/"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.array)]),
      withTagsMixin(tags): { spec+: { global+: { tags+: if std.isArray(v=tags) then tags else [tags] } } },
    },
    '#withOverride':: d.fn(help='"Override the default configurations of the agents"', args=[d.arg(name='override', type=d.T.object)]),
    withOverride(override): { spec+: { override: override } },
    '#withOverrideMixin':: d.fn(help='"Override the default configurations of the agents"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='override', type=d.T.object)]),
    withOverrideMixin(override): { spec+: { override+: override } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
